Os Hooks do ReactJS são um dos recursos mais poderosos do React, introduzidos na versão 16.8. Eles permitem que os desenvolvedores usem estados e outros recursos do React sem precisar escrever um componente de classe. Os Hooks simplificam o código, tornam-no mais legível e oferecem uma abordagem mais funcional ao desenvolvimento em React. Com os Hooks, os recursos de estado e ciclo de vida do React podem ser usados ​​em componentes funcionais, tornando-os muito mais poderosos do que antes.

## O que são Hooks no React

****React Hooks**** são funções que permitem que ****componentes funcionais**** no React gerenciem ****estados**** , tratem efeitos colaterais e acessem outros recursos do React sem a necessidade de componentes de classe. Eles fornecem uma maneira mais simples e eficiente de gerenciar a lógica dos componentes.

### Por que usar React Hooks?

- ****Simplifica o código:**** os ganchos fornecem uma maneira mais simples e limpa de escrever componentes usando funções em vez de classes.
- ****Estado e efeitos colaterais:**** os ganchos permitem que você use estado (useState) e efeitos colaterais (useEffect) em componentes funcionais.
- ****Reutilização:**** os ganchos facilitam o compartilhamento de lógica entre componentes criando ganchos personalizados.
- ****Legibilidade:**** componentes funcionais com ganchos tendem a ser mais concisos e fáceis de ler do que componentes de classe.

## Tipos de React Hooks

O React oferece vários ganchos para lidar com estados, efeitos colaterais e outras funcionalidades em componentes funcionais. Abaixo estão alguns dos tipos de ganchos do React mais comumente usados:

### 1. Ganchos de Estado

Ganchos de estado, especificamente [useState](https://www.geeksforgeeks.org/reactjs-usestate-hook/) e [useReducer](https://www.geeksforgeeks.org/reactjs-usereducer-hook/) , permitem que componentes funcionais gerenciem estados de forma mais eficiente e modular. Eles oferecem uma abordagem mais fácil e limpa para gerenciar estados no nível do componente em comparação com componentes de classe.

****useState:**** O gancho useState é usado para declarar variáveis ​​de estado em componentes funcionais. Ele nos permite ler e atualizar o estado dentro do componente.

****Sintaxe****
```
const [estado, setState] = useState(initialState);
```
- ****estado:**** O valor atual do estado.
- ****setState:**** Uma função usada para atualizar o estado.
- ****initialState:**** O valor inicial do estado, que pode ser um tipo primitivo ou um objeto/matriz

****useReducer:**** O gancho useReducer é um gancho de gerenciamento de estado mais avançado usado para lidar com lógica de estado mais complexa, geralmente envolvendo vários subvalores ou transições de estado mais complexas.

****Sintaxe****
```
const [estado, despacho] = useReducer(redutor, estadoinicial);
```

- ****estado:**** O valor do estado atual.
- ****dispatch:**** Uma função usada para despachar ações que atualizarão o estado.
- ****redutor:**** Uma função que define como o estado deve mudar com base na ação despachada.
- ****initialState:**** O valor do estado inicial.

Agora vamos entender como o gancho de estado funciona usando este exemplo

```
import React, { useState } from "react";

function App() {
    const [count, setCount] = useState(0);
    const increment = () => setCount(count + 1);
    const decrement = () => setCount(count - 1);

    return (
        <div>
            <h1>Count: {count}</h1> {/* Display the current count */}
            <button onClick={increment}>Increment</button> {/* Increment the count */}
            <button onClick={decrement}>Decrement</button> {/* Decrement the count */}
        </div>
    );
}

export default App;
```

****Neste código****

- useState é usado para declarar variáveis ​​de estado em componentes funcionais.
- A variável de estado (count) e a função atualizadora (setCount) permitem que você leia e atualize o estado.

### 2. Ganchos de contexto

O hook [useContext]() no React é uma maneira poderosa e conveniente de consumir valores da [API de Contexto do React]() em componentes funcionais. Ele permite que componentes funcionais acessem valores de contexto diretamente, sem a necessidade de passar propriedades manualmente pela árvore de componentes.  
const contextValue = useContext(MyContext);

```
const contextValue = useContext(MeuContexto);
```

- O gancho useContext recebe um objeto de contexto (MyContext) como argumento e retorna o valor atual desse contexto.
- O contextValue conterá o valor fornecido pelo <MyContext.Provider> mais próximo na árvore de componentes.

Agora vamos entender como o gancho de contexto funciona usando este exemplo

```
import React, { createContext, useContext, useState } from "react";

const ThemeContext = createContext();

function App() {
    const [theme, setTheme] = useState("light");

    const toggleTheme = () => {
        setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
    };

    return (
        <ThemeContext.Provider value={theme}>
            <div>
                <h1>Current Theme: {theme}</h1>
                <button onClick={toggleTheme}>Toggle Theme</button>
                <ThemeDisplay />
            </div>
        </ThemeContext.Provider>
    );
}

function ThemeDisplay() {
    const theme = useContext(ThemeContext);

    return <h2>Theme from Context: {theme}</h2>;
}

export default App;
```

****Neste código:****

- useContext permite que você consuma valores de contexto, facilitando o compartilhamento de dados entre componentes sem a necessidade de detalhamento de propriedades.
- O Provedor torna o valor de contexto acessível a todos os componentes abaixo dele na árvore de componentes.

### 3. Ganchos de Efeito

Os ganchos de efeito, especificamente [useEffect,]() [useLayoutEffect]() e [useInsertionEffect]() , permitem que componentes funcionais manipulem efeitos colaterais de uma forma mais eficiente e modular.

****useEffect:**** O hook useEffect no React é usado para lidar com efeitos colaterais em componentes funcionais. Ele permite que você execute ações como busca de dados, manipulação de DOM e configuração de assinaturas, que normalmente são tratadas em métodos de ciclo de vida como [componentDidMount]() ou [componentDidUpdate]() em componentes de classe.

****Sintaxe****
```
useEffect(() => {   
    // Lógica de efeito colateral aqui   
}, [dependências]);
```
- useEffect(() => { … }, [dependências]); executa efeitos colaterais após a renderização.
- O efeito é executado com base nas alterações nas dependências especificadas.

****useLayoutEffect:**** O useLawetEffect é usado quando precisamos medir ou manipular o lawet antes que o navegador pinte, garantindo transições suaves e sem oscilações.

****Sintaxe****
```
useLayoutEffect(() => {   
  // Lógica para manipular layout ou medir elementos DOM   
}, [dependências]);
```
****useInsertionEffect:**** O useInsertionEffect foi projetado para injetar estilos antecipadamente, especialmente útil para renderização do lado do servidor (SSR) ou bibliotecas de estilo, garantindo que os estilos estejam no lugar antes que o componente seja renderizado visualmente.

****Sintaxe****
```
useInsertionEffect(() => {   
    // Lógica para injetar estilos ou manipular folhas de estilo   
}, [dependências]);
```
Agora vamos entender como o gancho de efeito funciona usando este exemplo:

```
import React, { useState, useEffect } from "react";

function App() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        document.title = `Count: ${count}`;
        console.log(`Effect ran. Count is: ${count}`);

        return () => {
            console.log("Cleanup for previous effect");
            document.title = "React App";
        };
    }, [count]);

    return (
        <div>
            <h1>Count: {count}</h1>
            <button onClick={() => setCount(count + 1)}>Increment Count</button>
        </div>
    );
}

export default App;
```

****Neste código****

- useEffect é ótimo para lidar com efeitos colaterais como busca de dados, assinaturas ou manipulação manual do DOM (como alterar o título do documento).
- A função de limpeza é útil para limpar recursos (como temporizadores ou ouvintes de eventos) quando o componente é desmontado ou antes que o efeito seja executado novamente.

### 4. Gancho de Desempenho

Ganchos de desempenho no React, como [useMemo](https://www.geeksforgeeks.org/react-js-usememo-hook/) e [useCallback](https://www.geeksforgeeks.org/react-js-usecallback-hook/) , são usados ​​para otimizar o desempenho evitando novas renderizações ou recálculos desnecessários.

****useMemo:**** useMemo é um hook do React que memoriza o resultado de um cálculo caro, impedindo que ele seja recalculado a cada renderização, a menos que suas dependências sejam alteradas. Isso é particularmente útil quando temos um cálculo caro em termos de desempenho e queremos evitar recalculá-lo a cada ciclo de renderização.

****Sintaxe****

```
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

****useCallback:**** O useCallback é um hook do React que ajuda a memorizar funções, garantindo que uma função não seja redefinida em cada renderização, a menos que suas dependências sejam alteradas. Isso é particularmente útil ao passar funções como props para componentes filhos, pois evita rerenderizações desnecessárias desses componentes filhos.

****Sintaxe****

```
const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);
```

- useMemo armazena em cache o valor calculado (num * 2), recalculando-o somente quando num muda.
- Isso evita cálculos desnecessários em cada renderização.

Agora vamos entender como o gancho de desempenho funciona usando este exemplo

```
import React, { useState, useMemo } from "react";

function App() {
    const [count, setCount] = useState(0);
    const [text, setText] = useState("");

    const expensiveCalculation = useMemo(() => {
        console.log("Expensive calculation...");
        return count * 2;
    }, [count]);

    return (
        <div>
            <h1>Count: {count}</h1>
            <h2>Expensive Calculation: {expensiveCalculation}</h2>
            <button onClick={() => setCount(count + 1)}>Increment Count</button>

            <input
                type="text"
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Type something"
            />
        </div>
    );
}

export default App;
```

****Neste código****

- useMemo memoriza o resultado de expensiveCalculation.
- Ele só recomputa quando a contagem muda.
- Quando o texto é alterado, o cálculo não é executado novamente, otimizando o desempenho.
- console.log aparece somente quando a contagem muda, mostrando que a memorização funciona.

### 5. Ganchos de recursos (useFetch)

O useFetch é normalmente um gancho personalizado usado para buscar dados de uma API. Ele é implementado com useEffect para buscar dados quando o componente é montado ou quando as dependências são alteradas.

****Synatx****

```
const { dados, carregando, erro } = useFetch(url);
```

- useFetch é um gancho personalizado para buscar dados de uma determinada URL.
- Ele usa useEffect para buscar dados quando a URL muda e atualiza o estado dos dados.

Agora vamos entender como o gancho de recurso funciona usando este exemplo

```
import React, { useState, useRef } from "react";

function App() {
    const countRef = useRef(0);
    const [forceRender, setForceRender] = useState(false);

    const increment = () => {
        countRef.current += 1;
        setForceRender(!forceRender);
    };

    return (
        <div>
            <h1>Count: {countRef.current}</h1> {/* Display count value */}
            <button onClick={increment}>Increment</button>
        </div>
    );
}

export default App;
```

****Neste código****

- countRef contém o valor de contagem mutável.
- useState (forceRender) aciona novas renderizações para refletir alterações na interface do usuário.
- Quando o botão Incrementar é clicado, countRef é atualizado.
- setForceRender força uma nova renderização para atualizar a interface do usuário.
- A contagem atualizada é exibida em uma tag h1, não em um prompt.

### 6. Outros ganchos

O React oferece ganchos adicionais para casos de uso específicos

- [****useReducer****]() ****:**** Para gerenciamento de estado complexo.
- [****useImperativeHandle****]() ****:**** personaliza o valor da instância exposto por useRef.
- [****useLawetEffect****]() ****:**** como useEffect, mas dispara sincronicamente após atualizações do DOM.

### 7. Ganchos personalizados

[Ganchos personalizados]() são funções definidas pelo usuário que encapsulam lógica reutilizável. Eles melhoram a reutilização e a legibilidade do código ao compartilhar o comportamento entre os componentes.
```
//useWidth.js

import { useState, useEffect } from "react";

function useWidth() {
    const [width, setWidth] = useState(window.innerWidth);

    useEffect(() => {
        const handleResize = () => setWidth(window.innerWidth);
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
    }, []);

    return width;
}

export default useWidth;
```

****Usando um gancho personalizado****

```
import React from "react";
import useWidth from "./useWidth";

function App() {
    const width = useWidth();
    return <h1>Window Width: {width}px</h1>;
}

export default App;
```

- O gancho personalizado useWidth encapsula a lógica para rastrear a largura da janela.
- Ele reduz a redundância reutilizando a lógica entre os componentes.

> podemos ver uma lista completa de React Hooks em [****Referência completa de ReactJS Hooks****]()) ****.****

## ****Benefícios do uso de Hooks****

Os ganchos podem melhorar a reutilização do código e facilitar a divisão de componentes complexos em funções menores.

- ****Código mais simples e limpo:**** componentes funcionais com ganchos geralmente são mais concisos e fáceis de entender do que componentes de classe.
- ****Melhor para interfaces de usuário complexas**** : ganchos facilitam o gerenciamento de estado e efeitos colaterais em componentes com lógica complexa.
- ****Melhor manutenção**** : o código que usa ganchos geralmente é mais fácil de testar e depurar.

## ****Por que a necessidade dos Hooks do ReactJS?****

Veja por que os Hooks do ReactJS são necessários:

- ****Simplifica o gerenciamento de estado:**** os ganchos permitem um gerenciamento de estado mais fácil em componentes funcionais sem a necessidade de componentes de classe.
- ****Elimina a palavra-chave 'this':**** A complexidade de gerenciar this em componentes de classe é evitada, tornando o código mais limpo.
- ****Lógica reutilizável:**** os ganchos permitem o compartilhamento de lógica com estado entre componentes sem alterar as hierarquias dos componentes.
- ****Estrutura de código aprimorada:**** o código se torna mais modular e mais fácil de manter usando ganchos para gerenciar diferentes preocupações.
- ****Código mais limpo:**** componentes funcionais com ganchos são mais concisos, reduzindo o código clichê em comparação aos componentes de classe.
- ****Melhor experiência do desenvolvedor:**** o hot reloading funciona melhor com ganchos, melhorando o fluxo de trabalho geral do desenvolvedor.

## Regras para usar Hooks

- Somente componentes funcionais podem usar ganchos
- Os ganchos devem ser importados do React
- A chamada de ganchos deve sempre ser feita no nível superior dos componentes
- Os ganchos não devem estar dentro de instruções condicionais

## Diferença entre ganchos e componentes de classe

|Recurso|Componentes de classe|Ganchos de reação|
|---|---|---|
|****Gestão Estadual****|this.state e métodos de ciclo de vida|useState e useEffect|
|****Estrutura do código****|Distribuídos por métodos, podem ser complexos|Funções menores e focadas|
|****Reutilização****|Lógica difícil de reutilizar|Ganchos personalizados fáceis de criar e reutilizar|
|****Curva de Aprendizagem****|Familiar para desenvolvedores de POO|Requer uma mentalidade diferente das aulas|
|****Limites de erro****|Suportado|Não suportado atualmente|
|****Bibliotecas de terceiros****|Algumas bibliotecas dependem delas|Pode ser que nem todos sejam compatíveis ainda|

## ****Coisas importantes para lembrar ao usar ganchos****

- Os ganchos são opcionais no React 16.8+, permitindo a adoção parcial ou total do projeto sem reescrever o código existente.
- Os ganchos são compatíveis com versões anteriores, garantindo integração suave com componentes existentes e evitando alterações significativas.
- O React não tem planos de eliminar classes; Hooks e componentes de classe podem coexistir.
- Projetos React podem combinar perfeitamente componentes funcionais e baseados em classes com Hooks.
- Os ganchos fornecem uma API direta para conceitos-chave do React, como props, estado, contexto, refs e ciclo de vida.






