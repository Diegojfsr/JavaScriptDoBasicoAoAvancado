O Hook useRef é um Hook React integrado que retorna um objeto de referência mutável (ref) que persiste em todas as renderizações. Ao contrário das variáveis ​​de estado, atualizar uma ref não aciona uma nova renderização do componente.

****Sintaxe****

```
const refContainer = useRef(valorinicial);

```
- useRef retorna um objeto { current: initialValue }.
- A propriedade .current pode ser atualizada sem renderizar novamente o componente.

## Implementando o gancho useRef

### ****1.**** Acessando o DOM usando o gancho useRef.

Neste exemplo, temos um botão chamado ACTION. Sempre que clicamos no botão, o onClickHandler é acionado e foca a textarea com a ajuda do hook useRef.
```
import React, { Fragment, useRef } from 'react';

function App() {
    const focusPoint = useRef(null);
    const onClickHandler = () => {
        focusPoint.current.value =
            "The quick brown fox jumps over the lazy dog";
        focusPoint.current.focus();
    };
    return (
        <Fragment>
            <div>
                <button onClick={onClickHandler}>
                    ACTION
                </button>
            </div>
            <label>
                Click on the action button to
                focus and populate the text.
            </label><br />
            <textarea ref={focusPoint} />
        </Fragment>
    );
};
export default App;
```

****Neste exemplo****

- useRef cria um focusPoint de referência, que permite a manipulação direta do elemento DOM.
- Clicar no botão “AÇÃO” aciona o onClickHandler, que define o texto na textarea e o focaliza.
- `<Fragment> (<>…</>)` é usado para agrupar vários elementos sem adicionar wrappers extras no DOM.

### 2. Valores persistentes em renderizações

Além de acessar elementos DOM, useRef é útil para armazenar valores que persistem entre renderizações. Um caso de uso comum é armazenar um valor anterior, como o estado ou as propriedades anteriores.
```
import React, { useState, useRef, useEffect } from "react";
function PreviousValue() {
    const [count, setCount] = useState(0);
    const prevCountRef = useRef();

    useEffect(() => {
        prevCountRef.current = count;
    }, [count]);

    return (
        <div>
            <p>Current count: {count}</p>
            <p>Previous count: {prevCountRef.current}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}
export default PreviousValue;
```

****Neste exemplo****

- `count is a state variable that tracks the current count.`
- prevCountRef é uma referência criada com useRef para armazenar o valor de contagem anterior.
- Sempre que a contagem muda, o gancho useEffect atualiza prevCountRef.current para armazenar a contagem anterior.
- Clicar no botão aumenta a contagem em 1 e atualiza as contagens atual e anterior.

## Coisas interessantes sobre o gancho useRef

- ****Não causa novas renderizações:**** Ao contrário das variáveis ​​de estado, a atualização de um valor useRef não aciona uma nova renderização do componente. Isso o torna útil para armazenar valores que persistem entre renderizações sem causar atualizações desnecessárias.
- ****Acessando elementos DOM:**** useRef é comumente usado para referenciar elementos DOM diretamente, permitindo operações como focar campos de entrada, gerenciar animações e interagir com elementos sem causar novas renderizações.
- ****Rastreamento de alterações de estado:**** pode ser usado para armazenar valores de estado anteriores e rastrear alterações entre renderizações, o que é útil para comparar valores atuais e anteriores sem afetar as atualizações de componentes.

## Quando usar useRef?

****Você deve usar useRef quando****

- Acessar e manipular elementos DOM sem acionar novas renderizações.
- Persistência de valores em renderizações sem causar novas renderizações.
- Armazenando valores de estado anteriores para comparar alterações entre renderizações.
- Otimizando o desempenho evitando atualizações de estado desnecessárias.

## useRef vs useState

Embora useRef e useState possam armazenar valores, eles se comportam de maneira diferente:

- useRef não aciona novas renderizações quando atualizado, tornando-o ideal para persistir valores entre renderizações.
- useState aciona novas renderizações sempre que o valor do estado é atualizado.
- Use useRef para armazenar referências e preservar valores, e useState para atualizações da interface do usuário.

## Considerações de desempenho

Usar useRef corretamente pode melhorar o desempenho, mas o uso excessivo pode introduzir complexidade desnecessária.

- ****Use-o para valores não renderizados:**** ideal para persistir valores como temporizadores, estados anteriores ou elementos DOM.
- ****Evite usá-lo como substituição de estado:**** se forem necessárias atualizações da interface do usuário, use useState.
- ****Meça antes de otimizar:**** use o React DevTools para analisar o desempenho.




