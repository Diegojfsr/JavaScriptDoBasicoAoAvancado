Em aplicativos React, às vezes, gerenciar o estado em componentes profundamente aninhados pode se tornar muito difícil. O hook useContext oferece uma solução simples e eficiente para compartilhar o estado entre componentes sem a necessidade de detalhamento de propriedades.

## O que é o hook useContext?

O hook useContext no React permite que componentes consumam valores do contexto do React. A API de contexto do React foi projetada principalmente para passar dados pela árvore de componentes sem passar propriedades manualmente em todos os níveis. useContext faz parte do sistema de hooks do React, introduzido no React 16.8, que permite que componentes funcionais acessem valores de contexto.

Isso ajuda a evitar o problema de “prop drilling”, em que os adereços são passados ​​por vários níveis, dos componentes pai para os filhos.

- Simplifica o acesso ao estado compartilhado entre componentes.
- Evita a perfuração de suportes, eliminando a necessidade de passar suportes por vários níveis.
- Funciona perfeitamente com a API de contexto do React para fornecer estado global.
- Ideal para gerenciar temas, autenticação ou preferências do usuário no aplicativo.

****Sintaxe****

```
const contextValue = useContext(MeuContexto);
```

- ****MyContext:**** O objeto de contexto é criado usando React.createContext().
- ****contextValue:**** O valor de contexto atual que podemos usar em nosso componente.

## Como funciona?

O hook useContext permite consumir valores de um Contexto [React]() , permitindo acesso fácil ao estado compartilhado entre vários componentes sem a [necessidade de detalhamento de propriedades]() . Veja como funciona:

- O gancho useContext consome valores de um React Context, tornando-os acessíveis a componentes funcionais.
- Primeiro, crie um objeto Context usando React.createContext(), que contém o estado compartilhado.
- Use useContext para acessar o valor de contexto em qualquer componente que precise dele, evitando a repetição de propriedades.
- Quando o valor do Contexto é atualizado, todos os componentes que consomem esse contexto são renderizados automaticamente com o novo valor.

## Criando um Contexto

Antes de usar useContext, precisamos criar um contexto usando React.createContext(). Este contexto fornecerá um valor que pode ser acessado por qualquer componente filho encapsulado em um Context.Provider.
```
import React, { createContext, useContext, useState } from 'react';

const MyContext = createContext();

function App() {
    const [value, setValue] = useState('Hello, World!');

    return (
        <MyContext.Provider value={value}>
            <ChildComponent />
        </MyContext.Provider>
    );
}

function ChildComponent() {
    const contextValue = useContext(MyContext);
    return <h1>{contextValue}</h1>;
}
```

- createContext() cria um objeto de contexto (MyContext) que contém um valor padrão.
- MyContext.Provider passa o valor do contexto para seus componentes filhos.
- useContext(MyContext) permite que componentes como ChildComponent acessem o valor do contexto.

## Implementando o gancho useContext

### 1. Gerenciando autenticação com useContext

useContext pode ser usado para gerenciar o estado de autenticação do usuário globalmente.
```
import React, { createContext, useContext, useState } from 'react';
const AuthContext = createContext();
function AuthProvider({ children }) {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    return (
        <AuthContext.Provider value={{ isLoggedIn, setIsLoggedIn }}>
            {children}
        </AuthContext.Provider>
    );
}
function LoginButton() {
    const { isLoggedIn, setIsLoggedIn } = useContext(AuthContext);
    return (
        <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
            {isLoggedIn ? 'Logout' : 'Login'}
        </button>
    );
}
function App() {
    return (
        <AuthProvider>
            <LoginButton />
        </AuthProvider>
    );
}
export default App;
```

****Neste exemplo****

- AuthContext é criado usando createContext() e AuthProvider gerencia o estado isLoggedIn, passando-o através do contexto.
- LoginButton usa useContext para acessar isLoggedIn e setIsLoggedIn do contexto e alterna o estado de login.
- O aplicativo renderiza o LoginButton encapsulado no AuthProvider, permitindo funcionalidade dinâmica de login/logout.

### 2. Compartilhando um tema entre componentes

Criaremos um contexto de tema e usaremos useContext para acessar seus valores em componentes filhos.
```
import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();
function ThemeProvider({ children }) {
    const [theme, setTheme] = useState('light');

    const toggleTheme = () => {
        setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
}
function ThemedComponent() {
    const { theme, toggleTheme } = useContext(ThemeContext);
    return (
        <div style={{ background: theme === 'light' ? '#fff' : '#333', 
            color: theme === 'light' ? '#000' : '#fff', padding: '20px', textAlign: 'center' }}>
            <p>Current Theme: {theme}</p>
            <button onClick={toggleTheme}>Toggle Theme</button>
        </div>
    );
}
function App() {
    return (
        <ThemeProvider>
            <ThemedComponent />
        </ThemeProvider>
    );
}

export default App;
```

****Neste exemplo****

- ThemeContext é criado usando createContext().
- ThemeProvider gerencia o estado do tema e fornece uma função toggleTheme.
- useContext(ThemeContext) em ThemedComponent permite acesso ao tema atual e a capacidade de alterná-lo.
- Clicar no botão alterna entre temas claros e escuros.

## Quando usar useContext

Podemos usar o useContext quando

- Precisamos de gerenciamento de estado global para temas, autenticação ou preferências do usuário.
- Queremos evitar a perfuração de suporte.
- Precisamos de compartilhamento de estado entre vários componentes sem uma biblioteca de gerenciamento de estado de terceiros.

## useContext vs. Prop Drilling

|Recurso|useContext|Perfuração de suporte|
|---|---|---|
|Desempenho|Bom (pode causar renderizações desnecessárias)|Eficiente|
|Melhor para|Aplicativos de pequeno a médio porte|Poucos níveis de componentes|
|Caso de uso|Compartilhamento de estado global|Passando adereços manualmente|

## Considerações de desempenho

****Para otimizar o desempenho ao usar ganchos do React:****

- ****Minimize as renderizações desnecessárias:**** evite renderizações desnecessárias memorizando valores e funções usando useMemo e useCallback.
- ****Inicialização de estado eficiente:**** use inicialização lenta em useState para cálculos caros.
- ****Efeitos de limpeza:**** sempre limpe os efeitos colaterais no useEffect para evitar vazamentos de memória.
- ****Limitar dependências:**** mantenha as dependências em useEffect mínimas para reduzir execuções desnecessárias.


