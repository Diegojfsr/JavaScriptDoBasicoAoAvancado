O useMemo Hook é um React Hook integrado que ajuda a otimizar o desempenho memorizando o resultado de uma computação e reutilizando-o, a menos que suas dependências sejam alteradas. Isso evita que cálculos caros sejam executados desnecessariamente durante a renderização de componentes.

****Sintaxe****

```
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

- O primeiro argumento é uma função que retorna o valor calculado.
- O segundo argumento é um array de dependências. Quando qualquer uma dessas dependências muda, a função é reavaliada.

****Vamos agora ver algumas das Aplicações Práticas do useMemo****

### 1. Otimizando Cálculos Caros

Vamos dar um exemplo em que temos um cálculo caro que não deve ser recalculado em cada renderização.
```
import React, { useState, useMemo } from "react";

function App() {
    const [number, setNumber] = useState(0);
    const squaredNum = useMemo(() => squareNum(number), [number]);
    const [counter, setCounter] = useState(0);
    const onChangeHandler = (e) => {
        setNumber(e.target.value);
    };
    const counterHander = () => {
        setCounter(counter + 1);
    };
    return (
        <div className="App">
            <h1>Welcome to Geeksforgeeks</h1>
            <input
                type="number"
                placeholder="Enter a number"
                value={number}
                onChange={onChangeHandler}
            ></input>

            <div>OUTPUT: {squaredNum}</div>
            <button onClick={counterHander}>Counter ++</button>
            <div>Counter : {counter}</div>
        </div>
    );
}
function squareNum(number) {
    console.log("Squaring will be done!");
    return Math.pow(number, 2);
}
export default App;
```

****Neste exemplo****

- useState gerencia o número (entrada do usuário) e o contador (cliques de botão).
- useMemo armazena em cache squareNum(número), recalculando somente quando o número muda.
- O campo de entrada atualiza o estado do número quando alterado.
- Clicar em “Contador ++” aumenta o estado do contador.
- O componente exibe a entrada, o valor quadrado memorizado e o contador.

### ****2. Prevenindo renderizações desnecessárias****

Às vezes, passar objetos ou matrizes como props para componentes filhos pode acionar novas renderizações desnecessárias devido a alterações de referência. useMemo pode ajudar a estabilizar esses valores.
```
import React, { useState, useMemo } from "react";

function Child({ userInfo }) {
    console.log("Child component rendered");
    return <p>User: {userInfo.name}</p>;
}
function Parent() {
    const [count, setCount] = useState(0);
    const userInfo = useMemo(() => ({ name: "GeeksforGeeks" }), []);
    return (
        <div>
            <p>Count: {count}</p>
            <Child userInfo={userInfo} />
            <button onClick={() => setCount(count + 1)}>Increment Count</button>
        </div>
    );
}
export default Parent;
```

****Neste exemplo****

- React, useState e useMemo são importados para gerenciamento e otimização de estado.
- ChildComponent exibe userInfo.name e registra renderizações.
- ParentComponent memoriza userInfo para evitar recriação.
- Clicar no botão atualiza a contagem e renderiza novamente o ParentComponent.
- ParentComponent exibe a contagem, ChildComponent e o botão.

## Quando usar o useMemo?

****Você deve usar useMemo quando****

- Você tem cálculos caros que não precisam ser executados novamente, a menos que certas dependências sejam alteradas.
- Você está lidando com grandes conjuntos de dados e precisa otimizar o desempenho.
- Você quer evitar renderizações desnecessárias de componentes filhos garantindo referências estáveis.

No entanto, evite usar useMemo em excesso, pois pode adicionar complexidade e sobrecarga de memória. Use-o somente quando necessário.

## Otimização de desempenho usando useMemo

O uso correto do useMemo pode melhorar significativamente o desempenho de aplicativos React. No entanto, o uso incorreto pode levar ao uso desnecessário de memória e ao aumento da complexidade. Aqui estão algumas considerações importantes:

- ****Evite usar useMemo para cálculos triviais:**** se o cálculo for leve, a memorização pode introduzir uma complexidade desnecessária.
- ****Use-o para cálculos caros:**** tarefas como filtrar grandes conjuntos de dados ou realizar cálculos intensivos podem se beneficiar do useMemo.
- ****Estabilize referências de objetos e matrizes:**** ao passar objetos ou matrizes para componentes filhos, useMemo ajuda a manter a mesma referência e evita renderizações desnecessárias.
- ****Meça antes de otimizar:**** sempre analise o desempenho do seu aplicativo usando o React DevTools ou ferramentas de criação de perfil antes de introduzir o useMemo.

## Principais conclusões

- ****Otimização de desempenho:**** o useMemo ajuda a otimizar cálculos caros.
- ****Evita renderizações desnecessárias:**** ajuda a estabilizar valores de referência passados ​​como adereços.
- ****Use com sabedoria:**** o uso excessivo do useMemo pode levar a uma complexidade desnecessária.



