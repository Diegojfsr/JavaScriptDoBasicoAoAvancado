****O hook useEffect do React**** lida com os efeitos do array de dependências. O  `useEffect` hook nos permite executar efeitos colaterais nos componentes. Busca de dados, atualização direta do DOM e temporizadores são alguns efeitos colaterais. Ele é chamado sempre que qualquer estado do array de dependências for modificado ou atualizado.

Neste artigo, exploraremos o que o hook useEffect faz, como usá-lo, casos de uso comuns e algumas práticas recomendadas a serem seguidas.

## O que é o hook useEffect no React?

O useEffect no [ReactJS](https://www.geeksforgeeks.org/react-tutorial/) é usado para lidar com efeitos colaterais, como busca de dados e atualização do DOM. Este hook é executado em cada renderização, mas também existe uma maneira de usar um array de dependências com o qual podemos controlar o efeito da renderização. O hook useEffect é vital para gerenciar efeitos colaterais em componentes funcionais.

****Sintaxe:****
```
useEffect(() => {   
    // A lógica do efeito colateral vai aqui   
    return () => {   
         // Lógica de limpeza (opcional)   
  };   
}, [dependências]);
```

- ****Função de efeito**** : é aqui que seu código de efeito colateral é executado.
- ****Função de limpeza**** : esta função de retorno opcional limpa efeitos colaterais como assinaturas ou temporizadores quando o componente é desmontado.
- ****Matriz de dependências**** : o React executa novamente o efeito se algum dos valores nesta matriz mudar.
## ****Por que escolher o gancho useEffect?****

O gancho useEffect é usado para lidar com efeitos colaterais em componentes funcionais, como busca de dados, atualização do DOM e configuração de assinaturas ou temporizadores. Ele é usado para imitar os métodos de ciclo de vida de componentes baseados em classes. A motivação por trás da introdução do gancho useEffect é eliminar os efeitos colaterais do uso de componentes baseados em classes.

Por exemplo, tarefas como atualizar o DOM, buscar dados de endpoints de API, configurar assinaturas ou timers, etc., podem levar a efeitos colaterais injustificados. Como o método de renderização é muito rápido para produzir um efeito colateral, é necessário usar métodos de ciclo de vida para observar os efeitos colaterais. 

## ****Como funciona?****

- Você chama  `useEffect` com uma função de retorno de chamada que contém a lógica do efeito colateral.
- Por padrão, esta função é executada após cada renderização do componente.
- Opcionalmente, você pode fornecer uma matriz de dependências como o segundo argumento.
- O efeito só será executado novamente se algum dos valores na matriz de dependências mudar.

## Importando o gancho useEffect

Para importar o gancho useEffect, escreva o seguinte código no nível superior do seu componente

```
importar { useEffect } de "react";
```

## ****strutura do gancho useEffect****

A sintaxe do gancho useEffect aceita dois argumentos onde o segundo argumento é opcional

### ****Sintaxe do gancho useEffect do React:****

```
useEffect(<FUNÇÃO>, <DEPENDÊNCIA>)
```

### React useEffect Hook ShortHand para:

- ****FUNÇÃO:**** contém o código a ser executado quando useEffect for acionado.
- ****DEPENDÊNCIA:**** é um parâmetro opcional, useEffect é acionado quando a dependência fornecida é alterada.

## Controle dos efeitos colaterais em usoEfeito:

1. Para executar useEffect em cada renderização não passe nenhuma dependência

```
useEffect(()->{   
    // Código de exemplo   
})
```

2. Para executar useEffect apenas uma vez na primeira renderização, passe qualquer array vazio na dependência

```
useEffect(()->{   
    // Código de exemplo   
}, [] )
```

3. Para executar useEffect na alteração de um valor específico, passe o estado e as propriedades no array de dependências.

```
useEffect(()->{   
    // Código de exemplo   
}, [props, state] )
```

### Exemplo de gancho UseEffect do React:

Vejamos um exemplo de como usar o gancho useEffect como um recurso que pode imitar os métodos de ciclo de vida, mas em componentes funcionais. O componente funcional terá a seguinte aparência:

****Exemplo:**** Este exemplo demonstra o uso de ganchos useEffect para renderizar as contagens de cliques.

```
//HookCounterOne.js

// useEffect is defined here

import { useState, useEffect } from "react";

function HookCounterOne() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        document.title = `You clicked ${count} times`;
    }, [count]);

    return (
        <div>
            <button onClick={() => setCount((prevCount) => prevCount + 1)}>
                Click {count} times{" "}
            </button>
        </div>
    );
}
export default HookCounterOne;
```

```
//App.js 

// Importing and using HookCounterOne

import React from "react";
import "./App.css";
import HookCounterOne from "./components/HookCounterOne";

function App() {
    return (
        <div className="App">
            <HookCounterOne />
        </div>
    );
}
export default App;
```

****Saída:**** Inicialmente, o título do documento diz “Você clicou 0 vezes”. Quando você clica no botão, o valor da contagem aumenta e o título do documento é atualizado.
- **`**useEffect**`**aciona uma função em cada renderização de componente, usando o React para executar tarefas especificadas com eficiência.
- Posicionado dentro do componente, ele concede acesso fácil ao [estado e aos adereços](https://www.geeksforgeeks.org/what-are-the-differences-between-props-and-state/) sem codificação adicional.
- Para replicar métodos de ciclo de vida em componentes funcionais, copie e personalize o trecho de código fornecido de acordo com suas necessidades.

## ****Maneiras de imitar métodos de ciclo de vida usando o gancho useEffect****

Sabemos que useEffect() é usado para causar efeitos colaterais em [componentes funcionais](https://www.geeksforgeeks.org/reactjs-functional-components/) e também é capaz de manipular os métodos de ciclo de vida componentDidMount(), componentDidUpdate() e componentWillUnmount() de componentes baseados em classe nos componentes funcionais.

### ****Para**** [****componentDidMount****](https://www.geeksforgeeks.org/reactjs-componentdidmount-method/)

```
useEffect(()=>{   
    //Você pode adicionar seu código aqui para a fase de montagem do componente   
    console.log("Montagem no Componente Funcional")   
},[])   
// adicionar uma matriz vazia garante que o useEffect seja acionado apenas uma vez   
// (quando o componente é montado)
```

### ****Para**** [****componentDidUpdate****](https://www.geeksforgeeks.org/reactjs-componentdidupdate-method/)

```
useEffect(()=>{   
    //Você pode adicionar seu código para atualizar a fase do componente   
    console.log("Atualizando no Componente Funcional")   
},[values])   
//os valores acionam a nova renderização sempre que são atualizados no seu programa,   
//você pode adicionar vários valores separando-os por vírgulas
```

### ****Para**** [****componentWillUnmount****](https://www.geeksforgeeks.org/reactjs-componentwillunmount-method/)

```
useEffect(()=>{   
    return()=>{   
    //Você pode adicionar seu código para a fase de desmontagem do componente   
    console.log("Componente funcional removido")   
    }   
},[])   
//Escreva todo o código da fase de desmontagem somente dentro da função de retorno de chamada
```











