O useState é uma alternativa ao gancho useReducer, preferível quando precisamos de uma atualização básica. Os ganchos useState são usados ​​para adicionar variáveis ​​de estado aos componentes. Para usar o gancho useState, precisamos importá-lo para o componente.

****Sintaxe****

```
const [estado, setState] = useState(initialState)
```

- ****estado:**** É o valor do estado atual.
- ****setState:**** É a função usada para atualizar o estado.
- ****initialState:**** É o valor inicial do estado.

## Implementando o gancho useState

### 1. Contador usando useState

Um exemplo comum de uso do useReducer é gerenciar o estado de um contador com ações para incrementar e decrementar o valor.

```
import { useState } from 'react';
export default function Counter() {
    const [count, setCount] = useState(0);

    function handleClick() {
        setCount(count + 1);
    }
    return (
        <button onClick={handleClick}>
            Click {count} me
        </button>
    );
}
```

****Neste exemplo****

- ****useState(0)**** : Inicializa a contagem com 0.
- ****setCount(count + 1):**** Atualiza o estado adicionando 1 ao valor atual.
- ****setCount(count – 1)**** : Diminui o estado em 1.

### 2. Gerenciando o estado de entrada do formulário

useState também é útil para manipular campos de entrada de formulário dinamicamente.
```
import React, { useState } from 'react';

function Form() {
    const [name, setName] = useState('');
    const [age, setAge] = useState('');
    const [submitted, setSubmitted] = useState(false);

    const handleSubmit = () => {
        setSubmitted(true);
    };

    return (
        <div>
            <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter your name"
            />
            <input
                type="number"
                value={age}
                onChange={(e) => setAge(e.target.value)}
                placeholder="Enter your age"
            />
            <button onClick={handleSubmit}>Submit</button>
            {submitted && <p>Form Submitted!</p>}
        </div>
    );
}

export default Form;
```

****Neste exemplo****

- ****useState(”):**** Inicializa nome e idade com uma string vazia.
- ****onChange={(e):**** setName(e.target.value)}: Atualiza o estado do nome conforme o usuário digita.
- ****onChange={(e):**** setAge(e.target.value)}: Atualiza o estado da idade conforme o usuário digita.
- ****setSubmitted(true):**** Marca o formulário como enviado.

## Coisas interessantes sobre o gancho useState

- ****Gerencia estados simples facilmente:**** useState é ideal para gerenciar atualizações de estado simples, como alternar valores, contadores e entradas de formulário.

```
const [contagem, setCount] = useState(0);
```

- ****Atualizações funcionais para o estado anterior:**** ao atualizar o estado com base no estado anterior, sempre use uma função para garantir o valor correto:

```
setCount(contagem anterior => contagem anterior + 1);
```

- ****Atualiza o estado de forma assíncrona:**** As atualizações de estado no React são assíncronas, o que significa que setState não reflete as alterações imediatamente. Em vez disso, as atualizações são agrupadas para melhor desempenho.
- ****O estado não se mescla automaticamente:**** Ao contrário de this.setState em componentes de classe, useState não mescla objetos automaticamente. Você deve espalhar o estado anterior manualmente.
- ****Pode conter qualquer tipo de dado:**** useState não se limita a valores primitivos; pode armazenar objetos, matrizes ou até mesmo funções
- ****Inicialização preguiçosa para desempenho:**** se a inicialização do estado for cara, você pode usar uma função para calculá-lo apenas uma vez

```
const [contagem, setCount] = useState(() => computeInitialValue());
```

- ****Atualizações de estado podem ser ignoradas se o mesmo valor for fornecido:**** o React ignora as novas renderizações se você atualizar o estado com o mesmo valor

```
const [valor, setValue] = useState(10);
setValue(10); // Nenhuma nova renderização ocorre
```

## Quando usar useState

Devemos usar o gancho useState quando:

- Precisamos de uma solução simples de gerenciamento de estado.
- Nós, componentes, temos um estado que muda ao longo do tempo.
- O estado não requer atualizações ou dependências complexas.

## useState vs useReducer

Os ganchos useState e [useReducer](https://www.geeksforgeeks.org/reactjs-usereducer-hook/) são usados ​​para gerenciar o estado no React, mas de maneiras diferentes:

|Recurso|useState|useRedutor|
|---|---|---|
|Complexidade|Gerenciamento de estado simples|Lida com lógica de estado complexa|
|Atualizações de estado|Atualiza o estado diretamente|Usa uma função redutora com ações|
|Legibilidade|Simples e fácil de usar|Requer a definição de manipuladores de ação|
|Caso de uso|Valor único ou poucos valores independentes|Estado complexo com múltiplos subvalores|

## Considerações de desempenho

- ****Evite problemas de re-renderização:**** useState atualiza o estado de forma assíncrona, o que pode causar re-renderizações desnecessárias. Para otimizar isso, podemos usar atualizações funcionais para alterações de estado dependentes.
- ****Otimize estados de componentes grandes:**** para estados complexos, use useReducer em vez de useState para evitar renderizações desnecessárias e melhorar o desempenho.











