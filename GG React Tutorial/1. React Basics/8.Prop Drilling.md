Prop drilling no React refere-se ao processo de passar dados (props) de um componente pai para componentes filhos profundamente aninhados por meio de vários componentes intermediários, mesmo que esses componentes intermediários não utilizem os dados diretamente. Isso pode levar a uma complexidade desnecessária e à redução da manutenibilidade.

```
import React from "react";

// Parent component that holds the message and passes it down
function Parent() {
    const message = "Hello from Parent";
    return (
        <div>
            <Child message={message} />
        </div>
    );
}

function Child({ message }) {
    return (
        <div>
            <Grandchild message={message} />
        </div>
    );
}

function Grandchild({ message }) {
    return (
        <div>
            <p>Message: {message}</p>
        </div>
    );
}

export default function App() {
    return (
        <div>
            <Parent />
        </div>
    );
}
```

****Output****
```
Message: Hello from Parent
```

Neste exemplo, a mensagem é passada do Pai para o Neto por meio do Filho, mesmo que o Filho não a utilize. Isso pode se tornar incontrolável à medida que o aplicativo cresce.

## Por que não devemos usar perfuração de suporte?

- ****Manutenção do código:**** passar propriedades por vários componentes torna o código mais difícil de ler e atualizar.
- ****Acoplamento de componentes:**** os componentes ficam fortemente acoplados aos seus componentes pais, tornando-os menos reutilizáveis.
- ****Problemas de escalabilidade:**** conforme o aplicativo cresce, a segmentação de componentes pode levar a uma hierarquia desordenada de componentes.
- ****Aumento do clichê:**** os desenvolvedores precisam passar manualmente os adereços em cada nível, o que leva à duplicação desnecessária do código.

## Como evitar a perfuração de suporte?

### 1. ****Usando a API de contexto****

A React Context API fornece uma maneira de compartilhar valores (como estado, funções ou constantes) entre componentes sem passar propriedades explicitamente.

```
import React, { createContext, useContext } from 'react';
const UserContext = createContext();
const App = () => {
    const userName = 'geeksforgeeks';
    return (
        <UserContext.Provider value={userName}>
            <Parent />
        </UserContext.Provider>
    );
};
const Parent = () => {
    return <Child />;
};
const Child = () => {
    return <GrandChild />;
};
const GrandChild = () => {
    const userName = useContext(UserContext); // Access context value
    return <p>Hello, {userName}!</p>;
};
export default App;
```

Saída
```
Olá geeksforgeeks!
```

****Neste exemplo****

- createContext() cria um contexto (UserContext) para compartilhar dados entre componentes.
- O componente App usa UserContext.Provider para passar userName ('geeksforgeeks') como o valor de contexto.
- ParentComponent e seus filhos (ChildComponent, GrandChildComponent) são encapsulados pelo provedor.
- GrandChildComponent acessa o valor de contexto usando useContext(UserContext).
- O valor ('geeksforgeeks') é exibido em uma tag p como “Olá, geeksforgeeks!”.

### 2. Usando ganchos personalizados

[Ganchos personalizados](https://www.geeksforgeeks.org/reactjs-custom-hooks/) são funções reutilizáveis ​​no React que encapsulam lógica com estado, começando com `use`(por exemplo, `useFetch`). Eles melhoram a reutilização do código, mantêm os componentes limpos e permitem o compartilhamento de lógica entre os componentes.

```
import React, { createContext, useContext } from "react";
const UserContext = createContext();
const useUser = () => { return useContext(UserContext); };
const App = () => {
    const userName = "GeeksforGeeks";

    return (
        <UserContext.Provider value={userName}>
            <Component />
        </UserContext.Provider>
    );
};
const Component = () => {
    return <Child />;
};
const Child = () => { return <Grand />; };
const Grand = () => {
    const userName = useUser();
    return <p>Hello, {userName}!</p>;
};
export default App;
```

Saída
```
Olá, GeeksforGeeks!
```

****Neste exemplo****

- createContext() cria UserContext para compartilhar dados entre componentes.
- useUser() é um gancho personalizado que envolve useContext(UserContext) para simplificar.
- O aplicativo fornece o valor de contexto (“GeeksforGeeks”) usando UserContext.Provider.
- Componentes aninhados (Componente, Filho, Grande) herdam o valor do contexto.
- Grand acessa o valor via useUser() e exibe “Olá, GeeksforGeeks!



